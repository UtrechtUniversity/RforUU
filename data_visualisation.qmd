---
title: "Tutorial 2: Data visualisation in R"
author:
  - name: Benjamin Delory & Daniil Scheifes
    orcid: 0000-0002-1190-8060
    email: b.m.m.delory@uu.nl
    affiliations:
      - name: Environmental sciences group, Copernicus institute of sustainable development, Utrecht University
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

## About this tutorial

Welcome to this tutorial on data visualisation in R!

Throughout this tutorial, **our goal is to provide you with basic tools for visualizing your datasets in R.** After organizing some variables, computing new ones, and filtering data for statistical analyses we are now left with plotting and visualizing our data. This tutorial is all about mastering this fundamental skill! Today we will be working with two datasets on plant communities across Eurasia: Wassen et al (2021) and *Sheifes et al., (2024)*. Aftwerwards, we will spatially visualize the locations used in the this course

Lets start with the first! Wassen et al. (2021) showed in their publication that threatened species are most commonly found in soils with relatively low phosphorus (P) and phosphorus (P) to Nitrogen (N) content. In this study, they determined a N to P median niche value and compared species that were threatened to those that were not using two boxplots. Today we will recreate and improve this visualization.

For this, we must install the most used data visualization package in the R programming language: ggplot2. With ggplot2, we can generate a wide variety of plots, including scatter plots, bar plots, histograms, box plots, and more, while having control over aesthetics such as colors, shapes, and labels by using a variety of functions.

So lets install and load ggplot2!

```{r}
# Install ggplot2 package
install.packages('ggplot2')

# Load the ggplot2 package 
library(ggplot2)
```

If you are stuck or want help, also check Help-\> Cheat Sheet -\> Data visualization with ggplot 2, where there is lots of help on ggplot.

**Figure 1 - Boxplots**

Now, we need to read the dataset (Wassen_fig2) in R from the Data folder (see data wrangling how this was done). Lets store the dataset in a dataframe called NP_sp. Afterwards check the dataframe. What are the columns that we need for our figure?

```{r}
#store data as dataframe 
#check with benjamin so the functions are similar.
NP_sp <- read.csv("Data/NPsp_Wassen.csv")
head(NP_sp)

```

The grammar used in ggplot is as following:

`ggplot(data = df, mapping = aes(x, y, other aesthetics))`

where df is the dataframe, and x and y the names of the columns you would like to call.

So lets do this first for our example.

```{r}
#create ggplot
ggplot(data = NP_sp, mapping = aes(threatened, NP_median))

```

As you can see there is no Boxplot, but the framework is there. That is because we have only created a frame, with x and y axis, but object are still missing. As we are aiming to add a boxplot we are using the geom_boxplot function. Within the geom_boxplot we can add certain aestathic preference such a width=1.

```{r}
#create ggplot
ggplot(data = NP_sp, mapping = aes(threatened, NP_median))+geom_boxplot(width=0.5)

```

It works, but we want to restyle the graph by use a white background. This is easily achieved by the function theme_minimal() (with lines or theme_classic without lines). Next we would like to fill the boxplots using a red (threatened) and blue (non-threatened) species. For this we use fill = threatened in the aesthetics of the ggplot and define a scale_color_manual(values=c('colour', etc)). See https://www.uvm.edu/\~ngotelli/Rscripts/ColorChart.pdf for nice colour names or #hex.

```{r}
#create ggplot
ggplot(data = NP_sp, mapping = aes(threatened, NP_median, fill=threatened))+geom_boxplot(width=0.5)+theme_minimal()+scale_fill_manual(values=c("steelblue2","firebrick2" ))
```

No we we will add points, as we would like to now the underlying data of the boxplot. You could use geom_point but this runs in to troubles.

```{r}
#create ggplot
ggplot(data = NP_sp, mapping = aes(threatened, NP_median, fill=threatened))+geom_boxplot(width=0.5)+theme_minimal()+scale_fill_manual(values=c("steelblue2","firebrick2" )) +geom_point()
```

The points all fall on one line and it is unclear how the data is distributed. To solve this we could use the funtion geom_jitter() and remove the point produced by the boxplots using outlier.shape = NA in geom_boxplot(). In geom_jitter we use the function alpha to make them a bit transparent, and width to determine how much the points are spread.

```{r}
#create ggplot
ggplot(data = NP_sp, mapping = aes(threatened, NP_median, fill=threatened))+geom_boxplot(width=0.5,outlier.shape = NA)+theme_minimal()+scale_fill_manual(values=c("steelblue2","firebrick2" )) +geom_jitter(alpha=0.2, width=0.1)
```

Finally I would like to remove the lines of the axis using the theme() function. this can be done by setting the axis.line = element_blank(). Furhermore, there is still a legend, but we dont need it; for this we add within theme the legend.position = "none". Lastly we should rename the labels of NP_median in N/P by using the function labs(y="name)".

```{r}
#create ggplot
ggplot(data = NP_sp, mapping = aes(threatened, NP_median, fill=threatened))+geom_boxplot(width=0.5,outlier.shape = NA)+theme_minimal()+scale_fill_manual(values=c("steelblue2","firebrick2" )) +geom_jitter(alpha=0.2, width=0.1)+ theme(axis.line = element_blank(),  legend.position = "none")+labs(y= "N/P")
```

If we would like to do make a similar comparison we could like to use the same code but then swap y in aes() for P_median and change the labs(). We can also save ggplots as an object. Lets save the N/P plots as np_box and the P boxplot as p_box.

```{r}
#create ggplot
np_box<-ggplot(data = NP_sp, mapping = aes(threatened, NP_median, fill=threatened))+geom_boxplot(width=0.5,outlier.shape = NA)+theme_minimal()+scale_fill_manual(values=c("steelblue2","firebrick2" )) +geom_jitter(alpha=0.2, width=0.1)+ theme(axis.line = element_blank(),  legend.position = "none")+labs(y= "N/P")

#create ggplot p_box
p_box<-ggplot(data = NP_sp, mapping = aes(threatened, P_median, fill=threatened))+geom_boxplot(width=0.5,outlier.shape = NA)+theme_minimal()+scale_fill_manual(values=c("steelblue2","firebrick2" )) +geom_jitter(alpha=0.2, width=0.1)+ theme(axis.line = element_blank(),  legend.position = "none")+labs(y= "P")
```

Now we have saved both boxplots we can combine the together to get one new figure. For this we use the ggarrange() function within the package ggpubr. Install and load that package. Afterwards we can make both object into one figure by providing ggarrange() with the objects. We should also provide the function with the nrow or ncol and the labels c("a", "b"). Last we can use the function ggsave to save a to an appropiate folder. lets make an output folder and save it there.

```{r}
install.packages('ggpubr')
library(ggpubr)


#make arrange
figure1<-ggarrange(p_box, np_box, labels = c("a", "b"), ncol = 2, nrow = 1)
figure1

#save the figure
ggsave("output/figure1.png", plot = figure1, dpi=400, width = 5, height = 4)
```

**Figure 2 - Scatter plots**

Scheifes et al. use cmtv.csv. Explain the concepts of community mean traits. If interested all R scripts are available to see how this is done. We will work with the output of the data wrangling stored in ctmvs. csv.

We would like to combine some of the results that show that community associations with fungi increase along a biomass, and decreases along a N to P gradient.

```{r}
##store data as dataframe 
#check with benjamin so the functions are similar.
NP_tr <- read.csv("Data/CMTV_Scheifes.csv")
head(NP_tr)
```

No we will make two ggplots: one by biomass, other one by N:P. We first need to store the aveAM as numeric using the as.numeric() function. afterwards, we will add point using geom_point. We will first start with makin the graph for biomass. colour should be grreen.

```{r}

NP_tr$aveAM<- as.numeric(NP_tr$aveAM)

#create ggplot
ggplot(data = NP_tr, mapping = aes(log(biomass_vascular_plants_g.m2), aveAM))+geom_point()+theme_classic()

```

As you can see, we have the data but there is no linear model in the graph. As the paper uses a more complex, but we will try to fit a linear model and present this in the figure. You can use the geom_smooth function witthout error margins to first show a linear model, where method = "lm" and se = FALSE

```{r}
ggplot(data = NP_tr, mapping = aes(x = log(biomass_vascular_plants_g.m2), y = aveAM)) + geom_point() + geom_smooth(method = "lm", se= FALSE)+ theme_classic()
```

As you can see the model is only a visualization but does not give you information on p r squared etc. to add this information you can use annotate. Run an lm and store the data of the R-squared and p - value in a new object. then we use annotate to provide the graph with the data by referring to the lm.

```{r}

#fit linear regression model
lm_model <- lm(aveAM ~ log(biomass_vascular_plants_g.m2), data = NP_tr)

#extract R-squared and p-value
rsquared <- summary(lm_model)$r.squared
p_value <- summary(lm_model)$coefficients[2,4]

ggplot(data = NP_tr, aes(x = log(biomass_vascular_plants_g.m2), y = aveAM)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)+ 
  annotate("text", x = 2, y = 0.5, label = paste("R^2 =", round(rsquared, 3), "\np =", format(p_value, digits = 2)), hjust = 1, vjust = 1, size = 4) +
  theme_classic()

```

Last we want to improve the graph by changing the colour with to green, make them a bit transparant, and change the colour of the line to red. Furhtermore, we need to change the names of y-axis to AM and of the x-axis to ln biomass (use

```{r}

AMbio<-ggplot(data = NP_tr, aes(x = log(biomass_vascular_plants_g.m2), y = aveAM)) +
  geom_point(color = "green4", alpha = 0.3, size =2) +
  geom_smooth(method = "lm", se = FALSE, colour = "red")+ 
  annotate("text", x = 2.5, y = 1, label = paste("R^2 =", round(rsquared, 3), "\np =", format(p_value, digits = 2)), hjust = 1, vjust = 1, size = 4) +
  labs(x = "ln biomass", y = "AM")+
  theme_classic()

AMbio
```

Can you now do similar for the data of nitrogen to phosphorus ratio, arrange them together and save them? You can also remove the axis.title.y and axis.text.y for the second figure as this is already provided in the first (see how we removed the axis line in figure1). To make sure the y-axis are aligned, use align ="h" for this. Also we need to make some extra left space in the second plot using plot.margin = margin() in theme.for As you maybe first will see is that the arrange does not fit in your frame. This will be corrected when you save it. If not, make the annotates a bit smaller.

```{r}

#fit linear regression model
lm_modelNP <- lm(aveAM ~ log(NP_vascular_plants), data = NP_tr)

#extract R-squared and p-value
rsquaredNP <- summary(lm_modelNP)$r.squared
p_valueNP <- summary(lm_modelNP)$coefficients[2,4]

#create ggplot
AMNP<-ggplot(data = NP_tr, aes(x = log(NP_vascular_plants), y = aveAM)) +
  geom_point(color = "dodgerblue1", alpha = 0.3, size =2) +
  geom_smooth(method = "lm", se = FALSE, colour = "red")+ 
  annotate("text", x = 4, y = 1, label = paste("R^2 =", round(rsquaredNP, 3), "\np =", format(p_valueNP, digits = 2)), hjust = 1, vjust = 1, size = 4) +
  labs(x = "ln NP", y = "AM")+
    theme_classic()+
  theme(axis.title.y = element_blank(), axis.text.y = element_blank(), plot.margin = margin(0, 0, 0, 20))
AMNP


figure2<-ggarrange(AMbio, AMNP, labels = c("a", "b"), ncol = 2, nrow = 1, align = 'h')
figure2

#save the figure
ggsave("output/figure2.png", plot = figure2, dpi=400, width = 10, height = 5)
```

**Figure 3 - Mapping spatial data**

Lets continue with visualizing the locations in our course on a mat. For this, we will load point data with the location of your fieldwork together with a map for pH values of the top 5 cm (model of Helfenstein et al., ([2022](10.4121/16451739.v1))), highest ground water table (GWT) plus seepage and infiltration (model of AZURE and HYDROMEDAH). Lastly we will add a soil map BRO (Basisregistratie Ondergrond) to it. This data we will then visualize and create a map out of it.

Lets first install and load the packages for handling spatial data

```{r}
install.packages("sf")
library(sf)
library(raster)
library(rgdal)

```

Now we will load the locations of our field data (Locations_EFR.gpkg), which is a geopackage: an open, standards-based format for storing geospatial information. With the sf package we can read these geopackages, using st_read(). With ggplot we can show them using geom_sf() providing its location. Why do we not see a background map?

ggplot()+geom_sf(data = locations_sf)+theme_minimal()

```{r}
locations_sf <- st_read(dsn = "Data/Locations_EFR2.gpkg")

ggplot()+geom_sf(data = locations_sf)+theme_minimal()
```

Next, let's add the highest ground water table map to it We using the GWH_high.tif file for this. This is called a TIFF files, which is a Tagged Image File Format: it is a widely used file format for storing raster graphics images. We will use the function raster() to store this file. Thereafter, we will need to store it as a data_frame to use it in ggplot. Finaly we can use geom_raster to plot both rasters in ggplot. With scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 2, transform = "pseudo_log", na.value = "transparent") we are colouring the values; use fill = GWT_high as a fill in geom_raster.

```{r}
GWT<-raster("data/GWT_high.tif")


GWT_df <- as.data.frame(GWT, xy = TRUE)
KI2_df <- as.data.frame(KI2, xy = TRUE)

ggplot()+
geom_raster(data = GWT_df , aes(x = x, y = y, fill = GWT_high))+
  scale_fill_gradient2(low = "blue", mid = "white", high = "red",
                       midpoint = 2,
                         transform = "pseudo_log",
                       na.value = "transparent") +
geom_sf(data = locations_sf)+
theme_minimal()
```

Now lets check the soil types (Soil_OBR.gpkg). This is again a geopackage, but we need to transform it to make a ggplot with appropiate fill (VEREENV) for the soil types. can you transform V = Peat, DV = Peat, S =Sand, M =Clay and use scale_fill_manual to appropriate fill it? Do the location UHH and UHB have the same soil?

```{r}
soil_sf <- st_read(dsn = "Data/Soil_BRO.gpkg")

# Transform VEREENV variable
soil_sf$VEREENV <- ifelse(soil_sf$VEREENV == "DV", "Peat",
                          ifelse(soil_sf$VEREENV == "V", "Peat",
                                 ifelse(soil_sf$VEREENV == "M", "Clay",
                                        ifelse(soil_sf$VEREENV == "Z", "Sand",soil_sf$VEREENV))))


ggplot() +
geom_sf(data = soil_sf, aes(fill = VEREENV),alpha = 0.5) +
  geom_sf(data = locations_sf) +
  scale_fill_manual(name = "Soil Type",
                    values = c("Peat" = "black", "Sand" = "yellow", "Clay" = "brown")
                    ,na.value = "lightgrey") +
  theme_minimal()
```

We are missing a basemap in all these maps, so by using hte package [mapview](https://r-spatial.github.io/mapview/) we can add this easily! install that package, load it and use the function mapview to creat a map. for the soil_sf we should use VEREENV as zcol. See the [website](https://r-spatial.github.io/mapview/reference/mapView.html) and some [examples](https://r-spatial.github.io/mapview/articles/mapview_02-advanced.html) for many mapview functions. can you also add our GWT raster to it? lastly we save the map in your output folder using mapshot() and toggle out mapviewOptions(fgb = FALSE).

```{r}
install.packages('mapview')
library(mapview)
mapviewOptions(fgb = FALSE)

Map<-mapview(locations_sf,map.types = c("OpenStreetMap"))+
   mapview(soil_sf, zcol = "VEREENV",col.regions = c("brown", "lightgrey", "black", "yellow"), alpha.regions = 0.3,stroke = FALSE, map.types = c("OpenStreetMap"))
 
Map

mapshot(Map, file = "output/my_map.png", scalebar = TRUE)
```

Ask for Feedback following this link.

<link>
