{"title":"Tutorial 2: Data visualisation in R","markdown":{"yaml":{"title":"Tutorial 2: Data visualisation in R","author":[{"name":"Daniil Scheifes","email":"d.j.p.scheifes@uu.nl","affiliations":[{"name":"Environmental sciences group, Copernicus institute of sustainable development, Utrecht University"}]},{"name":"Benjamin Delory","orcid":"0000-0002-1190-8060","email":"b.m.m.delory@uu.nl","affiliations":[{"name":"Environmental sciences group, Copernicus institute of sustainable development, Utrecht University"}]}],"format":"html","editor":"visual","editor_options":{"chunk_output_type":"console"}},"headingText":"About this tutorial","containsRefs":false,"markdown":"\n\n\nWelcome to this tutorial on data visualisation in R!\n\nThroughout this tutorial, **our aim is to provide you with the basic tools for visualising your data in R**. After organizing some variables, computing new ones, and filtering data for statistical analyses, we are now left with plotting and visualising our data. The aim of this tutorial is to help you master this fundamental skill!\n\nWe will work with the following published dataset on plant communities across Eurasia: **Wassen MJ, Schrader J, van Dijk J, Eppinga MB**. **2021**. [Phosphorus fertilization is eradicating the niche of northern Eurasia's threatened plant species](https://www.nature.com/articles/s41559-020-01323-w). *Nature ecology & evolution* **5**: 67--73.\n\nAt the end of this tutorial, you will also learn how to map field site locations in R.\n\nLet's get started!\n\n## Introduction to *ggplot2*\n\nWhen visualising data in R, you can of course use base R functions (e.g., `plot`, `points`, `lines`, etc.), but this tutorial is only going to focus on functions of the *ggplot2* R package. This is because *ggplot2* can produce high-quality figures very quickly, even for complex ecological datasets. With *ggplot2*, you can generate a wide variety of graphs, including scatter plots, bar charts, histograms, box plots and much more, while having control over layouts, labels and aesthetics, such as colours, sizes and shapes. *ggplot2* relies on a coherent system for building graphs: the **grammar of graphics**. Using *ggplot2* requires you to learn a new grammar, which may sound overwhelming at first, but is in fact easy to learn because it relies on a simple set of core principles.\n\n::: callout-tip\n## ggplot2: Elegant Graphics for Data Analysis\n\nThis tutorial will only give you a very brief introduction to *ggplot2*. If you want to explore all the possibilities offered by *ggplot2* for data scientists, we recommend going through Hadley Wickham's reference book: **ggplot2: Elegant Graphics for Data Analysis**. To freely access the content of this book, just click on its cover.\n\n[![](Cover_ggplot2.jpg){fig-align=\"center\" width=\"200\"}](https://ggplot2-book.org/)\n:::\n\nIn this tutorial, we will use *ggplot2* to create the following graphs:\n\n-   A box plot to explore the relationship between a continuous response variable and a categorical predictor\n-   A scatter plot to explore the relationship between two continuous variables\n-   A map to visualise field site locations\n\n::: callout-tip\n## Posit Cheat Sheets\n\nPosit, the open source data science company behind RStudio, developed some very useful cheat sheets to help you remember how to use some of the core *tidyverse* packages, including *ggplot2*. You can download the ggplot2 cheat sheet using this [link](https://rstudio.github.io/cheatsheets/html/data-visualization.html?_gl=1*19kcxbo*_ga*NzQwNjg4NjIuMTcxMjA0NzkyNA..*_ga_2C0WZ1JHG0*MTcxMjMwNDYwNS4zLjEuMTcxMjMwNDcyMS4wLjAuMA..).\n:::\n\n## Load R packages\n\nThe first step is to load all the R packages needed for this tutorial. Since *ggplot2* is included in *tidyverse*, we just need to load the *tidyverse* library. We will also need a couple of other packages, including *knitr*, *viridis, Hmisc,* and *ggpubr*. Do not forget to install them if you do not have them in your library.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\nlibrary(tidyverse)\nlibrary(knitr)\nlibrary(viridis)\nlibrary(Hmisc)\nlibrary(ggpubr)\n```\n\n## Exercise 1: Creating a box plot\n\n### Import data into R\n\n[Wassen et al (2021)](https://www.nature.com/articles/s41559-020-01323-w) showed that threatened species are most commonly found in soils with relatively low phosphorus (P) and low P to Nitrogen (N) ratio. They determined a N:P median niche value and compared species that were threatened to those that were not using a box plot (see Figure 2 in the original paper). In this first exercise, we are going to recreate and improve this visualisation.\n\nAs the data is stored in a csv file (NPsp_Wassen.csv), we will use `read_csv()` to import the data into R. This csv file is stored in our working directory, in a folder called Data_ggplot2. Store data into an R object named `data_wassen`.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\n#Import data file (csv file)\ndata_wassen <- read.csv(\"Data_ggplot2/NPsp_Wassen.csv\")\n```\n\nHave a look at how the data frame looks like using `View()` or `head()`.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\nkable(head(data_wassen, n=10))\n```\n\nHaving examined the figure in the original article (Figure 2), what variables do you think are needed to recreate this figure?\n\n### Create a ggplot\n\nYou can start creating a plot using the function `ggplot()`. Later on, we will add new layers to this ggplot object. `ggplot()` has two main arguments: `data` and `mapping`. The `data` argument is used to specify the name of the dataset that should be used to create the graph. The `mapping` argument is used to specify how variables in your dataset are linked to visual properties (referred to **aesthetics**) of your plot. You should always use the `aes()` function for the `mapping` argument. The `x` and `y` arguments of `aes()` are used to choose the x (horizontal) and y (vertical) variables of your plot, respectively. The general syntax to create a ggplot object looks like this:\n\n`ggplot(data = your_data, mapping = aes(x, y, other aesthetics))`\n\nLet's create our first ggplot using **threatened** (i.e., whether a species is threatened or not) and **NP_median** (i.e., the N:P median niche value of each species in the dataset) as the x and y variables, respectively.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median))\n```\n\nAs you can see, the structure of the plot is there, but it does not display any data yet. This is because we have not specified in our code how our observations should be represented in our plot. You can do this by defining a **geom**. In *ggplot2*, there are a number of geom to choose from. Here are a few examples (but see [ggplot2 cheat sheet](https://rstudio.github.io/cheatsheets/data-visualization.pdf) for more examples):\n\n-   `geom_point()`: This geom is used to display individual data points and create a scatter plot.\n\n-   `geom_jitter()`: This geom is similar to `geom_point()` but jitters the data to improve readability.\n\n-   `geom_line()` and `geom_path()`: These geom are used to add lines connecting observations in your graph. While `geom_path()` connects observations in the order in which they appear in the data, `geom_line()` connects observations in the order of the variable plotted on the x axis of your graph.\n\n-   `geom_boxplot()`: This geom is used to create a box plot, which is particularly useful to display and compare the distribution of a response variable for different groups.\n\n-   `geom_bar()`: This geom is used to create bar charts.\n\n-   `geom_abline()`: This geom is used to add horizontal, vertical, and diagonal lines to your graph.\n\nAs we want to create a box plot, let's use `geom_boxplot()`. In `geom_boxplot()`, use the `width` argument to make boxes more narrow (by default, `width=1`).\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median))+\n  geom_boxplot(width=0.5)\n```\n\nIt's starting to look like a graph! We can improve it even further by plotting the raw data on top of the box plot. You can do this using `geom_jitter()`. In `geom_jitter()`, use the `width` argument to adjust the horizontal spread of the data points. Set also `height=0` to make sure that data points are only jittered horizontally. We will also use the `shape` argument to choose the symbol we want to use to represent each data point. There a number of options to choose from:\n\n```{r}\n#| eval: true\n#| echo: false\n#| warning: false\n#| message: false\n#| fig-width: 3\n#| fig-height: 3\n#| fig-align: center\n\ngenerateRPointShapes<-function(){\n  oldPar<-par()\n  par(font=2, mar=c(0.5,0,0,0))\n  y=rev(c(rep(1,6),rep(2,5), rep(3,5), rep(4,5), rep(5,5)))\n  x=c(rep(1:5,5),6)\n  plot(x, y, pch = 0:25, cex=1.5, ylim=c(1,5.5), xlim=c(1,6.5), \n       axes=FALSE, xlab=\"\", ylab=\"\", bg=\"#FFCD00\")\n  text(x, y, labels=0:25, pos=3)\n  par(mar=oldPar$mar,font=oldPar$font )\n}\ngenerateRPointShapes()\n```\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median))+\n  geom_boxplot(width=0.5)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1)\n```\n\nNote that the order in which you specify the different geom matters! If `geom_jitter()` is used before `geom_boxplot()`, most of the individual data points will be hidden behind the box plots.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median))+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1)+\n  geom_boxplot(width=0.5)\n```\n\n### Personalise your ggplot\n\nIn this section, we are going to personalise our plot by adding new layers and aesthetics.\n\nThe first thing we would like to do is to fill boxes with a specific colour for each group of species (threatened versus not threatened). To achieve this, we will have to provide additional information in `aes()`. We need to introduce two new arguments: `colour` (or `color`) and `fill`. As we want the two species categories to be displayed with a different color, we can use `fill=threatened` inside `aes()`.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median,\n                     fill = threatened))+\n  geom_boxplot(width=0.5)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1)\n```\n\nWhat would happen if you use `color=threatened` instead of `fill=threatened`? What do you notice? Change the code and give it a try!\n\nBy default, when assigning a specific color to each species group, *ggplot2* uses colors that are evenly spaced around a HCL (Hue Chroma Luminance) colour circle. However, this is not necessarily the best choice, especially for colour-blind people. The colour palettes provided by `viridis()` in the *viridis* R package have been specially designed to produce graphics that are pleasing to the eye, easier to read for colour-blind people and print well in greyscale. As shown in the figure below, eight colour palettes are available in *viridis*: **magma** (option A), **inferno** (option B), **plasma** (option C), **viridis** (option D, this is the default), **cividis** (option E), **rocket** (option F), **mako** (option G), and **turbo** (option H).\n\n[![Colour palettes available in the viridis R package](viridis.png){fig-align=\"center\" width=\"600\"}](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)\n\nLet's keep on personalising our plot by specifying that we want to use the viridis (option D) color palette to create the figure. This can be done with `scale_colour_viridis()` (`scale_color_viridis()` would work too) or `scale_fill_viridis()`. These functions have a couple of arguments to play with, including `alpha` (used to make colours more or less transparent), `direction` (to change the order of the colors in the scale), `discrete` (set to TRUE if you want to assign colours to a discrete scale such as groups), and `option` (to choose the colour palette you want to use). A list of colours available in R can also be found [here](https://www.uvm.edu/~ngotelli/Rscripts/ColorChart.pdf).\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median,\n                     fill = threatened))+\n  geom_boxplot(width=0.5)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1)+\n  scale_fill_viridis(discrete = TRUE,\n                     option = \"D\",\n                     alpha = 0.5)\n```\n\nNow that we are happy with the colors used in our plot, we can keep on personalising the layout by adding new layers to our ggplot. Let's do the following:\n\n-   Rename the axis titles so that it is clear to the reader which variables are represented. If your variables have units, do not forget to indicate them in the axis titles. We can personalise axis titles using `xlab()` and `ylab()`.\n-   ggplot2 comes with a number of built-in themes that can be used to personalise how your plot should look like. By default, `theme_grey()` is used (this is the reason why our plot has a grey background). Other popular themes are `theme_bw()` (black and white theme), `theme_minimal()` (minimalistic theme), and `theme_classic()` (a classic theme with axis lines but no gridlines). Many more themes are available in *ggplot2*. We will use `theme_bw()` to personalise our plot.\n-   Make the individual points a bit more transparent using the `alpha` argument in `geom_jitter()`.\n-   Remove the points labelled as outliers by `geom_boxplot()`. As individual data points are also displayed, this information is redundant. We can get rid of these points using `outliers = FALSE` in `geom_boxplot()`.\n-   Remove the legend on the right side of the plot because this information is already provided by the x axis. This can be done using `theme()` and setting `legend.position=\"none\"`. `theme()` is a particularly important function as it allows you to personalise many aspects of your plot, such as the color, size and orientation of the text along plot axes.\n-   Along the vertical axis, we would like to have breaks at the following N:P values: 5, 10, 15, 20, 25, 30. You can do this using `scale_y_continuous()`.\n-   Change the colour of the text along the horizontal and vertical axes to black. You can do this using `theme()` and `element_text()`.\n-   Add more space between axis titles and axis labels. You can do this in `theme()`, using the `margin` argument in `element_text()`.\n-   Remove the grey grid lines in the background of the plot. This can be done in `theme()`, using `panel.grid = element_blank()`.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median,\n                     fill = threatened))+\n  geom_boxplot(width=0.5,\n               outliers=FALSE)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1,\n              alpha=0.6)+\n  scale_fill_viridis(discrete = TRUE,\n                     option = \"D\",\n                     alpha = 0.5)+\n  theme_bw()+\n  xlab(\"Are species threatened?\")+\n  ylab(\"Median N:P ratio\")+\n  scale_y_continuous(breaks=seq(from = 5,\n                                to = 30,\n                                by = 5))+\n  theme(legend.position = \"none\",\n        axis.text = element_text(colour=\"black\"),\n        axis.title.x = element_text(margin = margin(t = 10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)),\n        panel.grid = element_blank()) #r means right\n```\n\n### Compute and display summary statistics\n\nWhen comparing groups to each other, we are often interested in comparing group means and their confidence limits (often represented as 95% confidence intervals). The function `stat_summary()` allows you to add this information to your ggplot. In `stat_summary()`, `fun.data = \"mean_cl_boot\"` can be used to calculate and display the average value and 95% confidence interval estimated by bootstrapping (which is a convenient way to estimate confidence intervals without assuming that the underlying data are normally distributed).\n\nTo improve readability, we want to plot these summary statistics on the right side of each box plot, using the same colour palette (tip: add `aes()` in `stat_summary()`). In `stat_summary()`, the `position` argument allows you to fine tune the position of plotted elements. The function `position_nudge()` allows you to shift the position of items along the vertical and horizontal axes by a small amount. In our case, shifting the position of summary statistics by 0.35 units to the right seems like a good idea.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median,\n                     fill = threatened))+\n  geom_boxplot(width=0.5,\n               outliers=FALSE)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1,\n              alpha=0.6)+\n  stat_summary(fun.data=\"mean_cl_boot\",\n               aes(colour = threatened),\n               position = position_nudge(x=0.35))+\n  scale_fill_viridis(discrete = TRUE,\n                     option = \"D\",\n                     alpha = 0.5)+\n  scale_colour_viridis(discrete = TRUE,\n                       option = \"D\")+\n  theme_bw()+\n  xlab(\"Are species threatened?\")+\n  ylab(\"Median N:P ratio\")+\n  scale_y_continuous(breaks=seq(from = 5,\n                                to = 30,\n                                by = 5))+\n  theme(legend.position = \"none\",\n        axis.text = element_text(colour=\"black\"),\n        axis.title.x = element_text(margin = margin(t = 10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)),\n        panel.grid = element_blank()) #r means right\n```\n\n### Integrating the pipe\n\nRemember the pipe? We introduced it in the data wrangling tutorial. How can we rewrite the code used to produce our figure using the pipe? Give it a try!\n\n```{r}\n#| eval: false\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\ndata_wassen |> \n  ggplot(mapping = aes(x = threatened, \n                       y = NP_median,\n                       fill = threatened))+\n  geom_boxplot(width=0.5,\n               outliers=FALSE)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1,\n              alpha=0.6)+\n  stat_summary(fun.data=\"mean_cl_boot\",\n               aes(colour = threatened),\n               position = position_nudge(x=0.35))+\n  scale_fill_viridis(discrete = TRUE,\n                     option = \"D\",\n                     alpha = 0.5)+\n  scale_colour_viridis(discrete = TRUE,\n                       option = \"D\")+\n  theme_bw()+\n  xlab(\"Are species threatened?\")+\n  ylab(\"Median N:P ratio\")+\n  scale_y_continuous(breaks=seq(from = 5,\n                                to = 30,\n                                by = 5))+\n  theme(legend.position = \"none\",\n        axis.text = element_text(colour=\"black\"),\n        axis.title.x = element_text(margin = margin(t = 10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)),\n        panel.grid = element_blank()) #r means right\n```\n\n### Arrange multiple ggplots\n\nOften, we produce multiple plots that we want to put together into one figure as separate panels. But how can we easily do this? The answer is: by using `ggarrange()` in the *ggpubr* R package. It is easier to use `ggarrange()` if each individual plot is stored in a different object. Let's do this and also create a second figure (very similar to the first) displaying median P values (in mg/g) instead of median N:P values. This time, use the `size` argument in `geom_jitter()` and `stat_summary()` to reduce the size of individual data points.\n\nOnce your two plots are created and stored in separate R objects, use `ggarrange()` to create one figure with two panels (1 row, 2 columns).\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 5.9\n#| fig-height: 3.94\n#| fig-align: center\n\n#Create individual plots\n\nplot_NP <- data_wassen |> \n              ggplot(mapping = aes(x = threatened, \n                                   y = NP_median,\n                                   fill = threatened))+\n              geom_boxplot(width=0.5,\n                           outliers=FALSE)+\n              geom_jitter(width=0.1, \n                          height=0, \n                          shape=1,\n                          alpha=0.6,\n                          size=1)+\n              stat_summary(fun.data=\"mean_cl_boot\", \n                           aes(colour = threatened),\n                           position = position_nudge(x=0.35),\n                           size=0.4)+\n              scale_fill_viridis(discrete = TRUE,\n                                 option = \"D\",\n                                 alpha = 0.5)+\n              scale_colour_viridis(discrete = TRUE,\n                                   option = \"D\")+\n              theme_bw()+\n              xlab(\"Are species threatened?\")+\n              ylab(\"Median N:P ratio\")+\n              scale_y_continuous(breaks=seq(from = 5,\n                                            to = 30,\n                                            by = 5))+\n              theme(legend.position = \"none\",\n                    axis.text = element_text(colour=\"black\"),\n                    axis.title.x = element_text(margin = margin(t = 10)), #t means top\n                    axis.title.y = element_text(margin = margin(r=10)),\n                    panel.grid = element_blank()) #r means right\n\nplot_P <- data_wassen |> \n            ggplot(mapping = aes(x = threatened, \n                                 y = P_median,\n                                 fill = threatened))+\n            geom_boxplot(width=0.5,\n                         outliers=FALSE)+\n            geom_jitter(width=0.1, \n                        height=0, \n                        shape=1,\n                        alpha=0.6,\n                        size=1)+\n            stat_summary(fun.data=\"mean_cl_boot\",\n                         aes(colour = threatened),\n                         position = position_nudge(x=0.35),\n                         size=0.4)+\n            scale_fill_viridis(discrete = TRUE,\n                               option = \"D\",\n                               alpha = 0.5)+\n            scale_colour_viridis(discrete = TRUE,\n                                 option = \"D\")+\n            theme_bw()+\n            xlab(\"Are species threatened?\")+\n            ylab(\"Median P concentration (mg/g)\")+\n            scale_y_continuous(breaks=seq(from = 0,\n                                          to = 4,\n                                          by = 0.5))+\n            theme(legend.position = \"none\",\n                  axis.text = element_text(colour=\"black\"),\n                  axis.title.x = element_text(margin = margin(t = 10)), #t means top\n                  axis.title.y = element_text(margin = margin(r=10)),\n                  panel.grid = element_blank()) #r means right\n\n#Combine plots with ggarrange()\n\n(plot_final <- ggarrange(plot_NP, #This is the first panel\n                         plot_P, #This is the second panel\n                         nrow = 1,\n                         ncol = 2,\n                         align = \"hv\", #Panels need to be horizontally and vertically aligned\n                         labels = \"auto\")) #Auto-generate lower-case labels for each subplot\n```\n\n### Export high-resolution figure\n\nOnce you are happy with your figure, you can export it as a high-resolution image file (png, tiff, jpg, etc.) for your paper or presentation using `ggsave()`. In `ggsave()`, important arguments are `filename` (the name of the image file, with file extension), `plot` (the name of your ggplot object), `dpi` (desired image resolution in dots per inch), `width` (image width), `height` (image height), and `units` (the units used for width and height). By default, the figure will be saved in your working directory (see `getwd()`).\n\n```{r}\n#| eval: false\n#| echo: true\n#| warning: false\n#| message: false\n\nggsave(filename = \"Boxplot_Wassen.png\",\n       plot = plot_final,\n       dpi = 1000,\n       width = 15,\n       height=10,\n       units=\"cm\")\n```\n\n## Exercise 2: Creating a scatter plot\n\nThe second exercise of this tutorial is to use the [Wassen et al (2021)](https://www.nature.com/articles/s41559-020-01323-w) data to create a scatter plot displaying the relationship between median phosphorus (P) and potassium (K) concentrations. We also want our figure to show how this relationship differs between species groups (i.e., threatened or not threatened). Let's have a look at how to do this with *ggplot2*.\n\n### Create a ggplot\n\nFirst, create a ggplot object displaying individual data points and clear axis titles (keep on using the pipe). Let's not worry about the threat status of the species just yet.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\ndata_wassen |> \n  ggplot(aes(x = K_median,\n             y = P_median))+\n  geom_point(shape = 1)+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10))) #r means right\n```\n\n### Personalise your ggplot\n\nIt is already a nice graph, but now we want to make it more informative by displaying the results separately for each group of species (threatened and non-threatened species). There are several ways of doing this. The first is to display the data points with a different shape (use `shape` in `aes()`) or a different colour (use `colour` or `color` in `aes()`). Let's do both! Feel free to play around with different shapes (`scale_shape_manual()`) and colour palettes. In the previous example, we used `scale_colour_viridis()` to choose our viridis colour palette. This time, we are going to define the colour options by combining `scale_color_manual()` and `viridis()`. Give it a try!\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 5\n#| fig-height: 4\n#| fig-align: center\n\ndata_wassen |> \n  ggplot(aes(x = K_median,\n             y = P_median,\n             colour = threatened,\n             shape = threatened))+\n  geom_point()+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)))+ #r means right\n  scale_shape_manual(values = c(16, 17))+\n  scale_colour_manual(values = viridis(n = 2, #Set number of colours\n                                       alpha = 0.5,\n                                       option = \"D\"))\n```\n\n### Faceting\n\nWe now have a graph showing the results separately for each group of species. However, it looks a little cluttered, with individual points overlapping each other. To improve readability, it would be preferable to present the data for threatened and non-threatened species in separate panels. This can be done with `facet_wrap()`. This function will divide our existing graph into subplots, each of which will display a subset of the data based on a categorical variable (threat status). Note that if you want to create subplots based on two variables in your dataset (a 'row' variable and a 'column' variable), using `facet_grid()` is more appropriate.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 5.9\n#| fig-height: 3.94\n#| fig-align: center\n\ndata_wassen |> \n  ggplot(aes(x = K_median,\n             y = P_median,\n             colour = threatened,\n             shape = threatened))+\n  geom_point()+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)))+ #r means right\n  scale_shape_manual(values = c(16, 17))+\n  scale_colour_manual(values = viridis(n = 2, #Set number of colours\n                                       alpha = 0.5,\n                                       option = \"D\"))+\n  facet_wrap(~threatened,\n             nrow=1,\n             ncol=2)\n```\n\n### Simplify your plot\n\nWe are getting closer to the final version of our graph, but there are still a few points to be ironed out:\n\n-   There is some redundancy in this figure because the threat status of plant species is represented by different colours, different dot shapes and in different panels. We should simplify things a little and avoid redundancy. Now that we have a specific panel for each category of species, it is no longer necessary to use a specific colour and shape for each category. This will also make it possible to do away with the legend on the right-hand side of the graph.\n-   In each panel, we would like to add a trend line ('smoother') to better visualise the shape of the relationship between our two continuous variables. This can be done using a new geom: `geom_smooth()`. In `geom_smooth()`, the `span` argument allows you to control the amount of smoothing (a large number will produce a smoother line).\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 5.9\n#| fig-height: 3.94\n#| fig-align: center\n\ndata_wassen |> \n  ggplot(aes(x = K_median,\n             y = P_median))+\n  geom_point(shape=1)+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)))+ #r means right\n  facet_wrap(~threatened,\n             nrow=1,\n             ncol=2)+\n  geom_smooth(span=1.5)\n```\n\n### Finalise your plot\n\nBefore exporting our graph as a high-resolution image file, we would like to do two things:\n\n-   Colour the trend lines using the same colours as those used for our box plot (just to make it prettier and more consistent). Make sure to remove the legend using `legend.position=\"none\"`.\n-   Rename the title of each subplot to make it more informative. Instead of \"No\" and \"Yes\", \"Not threatened\" and \"Threatened\" would be more informative. You can do this using `replace()` in `mutate()` (see tutorial on data wrangling).\n\nThat's what we need to do!\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 5.9\n#| fig-height: 3.94\n#| fig-align: center\n\ndata_wassen |> \n  mutate(threatened = replace(threatened, threatened == \"No\", \"Non-threatened\")) |>\n  mutate(threatened = replace(threatened, threatened == \"Yes\", \"Threatened\")) |>\n  ggplot(aes(x = K_median,\n             y = P_median))+\n  geom_point(shape=1)+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)),\n        legend.position=\"none\",\n        axis.text = element_text(colour = \"black\"))+ #r means right\n  facet_wrap(~threatened,\n             nrow=1,\n             ncol=2)+\n  geom_smooth(span=1.5,\n              aes(colour = threatened))+\n  scale_colour_viridis(option=\"D\",\n                       discrete = TRUE)\n```\n\n### Export high-resolution figure\n\nUse `ggsave()` to export your plot as a high-resolution image.\n\n```{r}\n#| eval: false\n#| echo: true\n#| warning: false\n#| message: false\n\nplot_final <- data_wassen |> \n  mutate(threatened = replace(threatened, threatened == \"No\", \"Non-threatened\")) |>\n  mutate(threatened = replace(threatened, threatened == \"Yes\", \"Threatened\")) |>\n  ggplot(aes(x = K_median,\n             y = P_median))+\n  geom_point(shape=1)+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)),\n        legend.position=\"none\",\n        axis.text = element_text(colour = \"black\"))+ #r means right\n  facet_wrap(~threatened,\n             nrow=1,\n             ncol=2)+\n  geom_smooth(span=1.5,\n              aes(colour = threatened))+\n  scale_colour_viridis(option=\"D\",\n                       discrete = TRUE)\n\nggsave(filename = \"Scatterplot_Wassen.png\",\n       plot = plot_final,\n       dpi = 1000,\n       width = 15,\n       height=10,\n       units=\"cm\")\n```\n\n## Exercise 3: Mapping spatial data\n\nCreating and extracting data from maps is very useful for ecological field research. This exercise will give you a brief introduction to mapping spatial data in R.\n\nFor this exercise, we will use the following files:\n\n-   A geopackage database file (GPKG) containing the spatial coordinates of field sites around Utrecht University (Locations_EFR.gpkg)\n\n-   A map of the highest ground water table (GWT_high.tif). This map is stored as a TIFF file (Tag Image File Format), which is a widely used file format for storing raster graphics images.\n\n-   A geopackage database file containing soil type information (Basisregistratie Ondergrond)\n\n### Load R packages to handle spatial data\n\nBefore starting this exercise, make sure that the *sf*, *raster*, and *mapview* packages are installed in your library.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\nlibrary(sf)\nlibrary(raster)\nlibrary(mapview)\n```\n\n### Import geospatial data\n\nGPKG files can be read using `st_read()` in th *sf* R package. Use this function to load the locations of our field sites into R. We can then plot these locations using `geom_sf()` in *ggplot2*.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-align: center\n\n#Read field site locations\nlocations_sf <- st_read(dsn = \"Data_ggplot2/Locations_EFR.gpkg\",\n                        quiet = TRUE)\n\n#Create a ggplot\nggplot(data = locations_sf)+\n  geom_sf()+\n  theme_minimal()\n```\n\nQuestion: Why do we not see a map in the background?\n\n### Add raster data (ground water)\n\nTo add information about the highest ground water table in the background of our map, we first need to read our raster data (GWT_high.tif) using `raster()`. This will create a RasterLayer object which will need to be converted into a data frame using `as.data.frame()` so that the data can be used in *ggplot2*. In our ggplot, use `geom_raster()` to add a raster layer to your graph.\n\nIn maps, the colour code used to display information is something to be considered carefully, so that your map is as informative and easy to understand as possible. In this ground water example, we would like areas with a high water table (i.e. low GWT_high values in our dataset) to appear in blue, while areas with a low water table (i.e. high GWT_high values in our dataset) would appear in red. Such a divergent colour gradient (low-medium-high) can be created using `scale_colour_gradient2()`. We will set the midpoint value to 2 (which means that values below 2 will appear blue, while values above 2 will appear red). We will also apply a pseudo-log transformation to improve the readability of our map. You can do this using the `transform` argument in `scale_fill_gradient2()`. As our raster data also contains missing values, we will use the `na.value` argument in `scale_fill_gradient2()` to make them transparent.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-align: center\n\n#Create RasterLayer object\nGWT<-raster(\"Data_ggplot2/GWT_high.tif\")\n\n#Convert to data frame\nGWT_df <- as.data.frame(GWT, \n                        xy = TRUE)\n\n#Plot raster and location data\nggplot()+\n  geom_raster(data = GWT_df, \n              aes(x = x, \n                  y = y, \n                  fill = GWT_high))+\n  geom_sf(data = locations_sf)+\n  theme_minimal()+\n  scale_fill_gradient2(name = \"Ground\\nwater\\ntable\",\n                       low = \"blue\", \n                       mid = \"white\", \n                       high = \"red\",\n                       midpoint = 2,\n                       transform = \"pseudo_log\",\n                       na.value = \"transparent\")\n```\n\nLet's now look at how we can customise the legend for this ggplot. It would be interesting to edit the break values along the colour bar and provide an informative title for each axis. Give it a try!\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-align: center\n\n#Plot raster and location data\nggplot()+\n  geom_raster(data = GWT_df, \n              aes(x = x, \n                  y = y, \n                  fill = GWT_high))+\n  geom_sf(data = locations_sf)+\n  theme_minimal()+\n  scale_fill_gradient2(\"Ground\\nwater\\ntable\",\n                       low = \"blue\", \n                       mid = \"white\", \n                       high = \"red\",\n                       midpoint = 2,\n                       transform = \"pseudo_log\",\n                       na.value = \"transparent\",\n                       breaks = c(0, 2, 10, 40))+\n  ylab(\"Latitude\")+\n  xlab(\"Longitude\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)),\n        axis.title.y = element_text(margin = margin(r=10)))\n```\n\n### Add more geospatial information (soil type)\n\nLet's create a new map with soil type information! Soil type data is stored as a geopackage (Soil_BRO.gpkg). You can read it using `st_read()`.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\nsoil_sf <- st_read(dsn = \"Data_ggplot2/Soil_BRO.gpkg\",\n                   quiet = TRUE)\n```\n\nIn `soil_sf`, the column 'VEREENV' contains soil type information. There are four soil type options in this column: DV (Peat), V (Peat), M (Clay), Z (Sand). Combine `mutate()` and `replace()` to rename elements in this column.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\nsoil_sf <- soil_sf |> \n  mutate(VEREENV = replace(VEREENV, VEREENV %in% c(\"DV\", \"V\"), \"Peat\")) |> \n  mutate(VEREENV = replace(VEREENV, VEREENV == \"M\", \"Clay\")) |> \n  mutate(VEREENV = replace(VEREENV, VEREENV == \"Z\", \"Sand\"))\n```\n\nNow let's create our map of soil types and plot our site locations on top of it (use `geom_sf()` in both cases). Use `scale_fill_manual()` to assign colours to each soil type.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-align: center\n\nggplot() +\n  geom_sf(data = soil_sf, \n          aes(fill = VEREENV),\n          alpha = 0.5) +\n  geom_sf(data = locations_sf) +\n  scale_fill_manual(name = \"Soil Type\",\n                    values = c(\"Peat\" = \"black\", \n                               \"Sand\" = \"yellow\", \n                               \"Clay\" = \"brown\"),\n                    na.value = \"transparent\") +\n  theme_minimal()+\n  ylab(\"Latitude\")+\n  xlab(\"Longitude\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)),\n        axis.title.y = element_text(margin = margin(r=10)))\n```\n\n### Adding a base map\n\nYour maps look great, but they are all missing a base map. This can be done using `mapView()` in *mapview*. Have a look at the code below to see how to add a base map to our soil type map.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| code-fold: false\n#| fig-align: center\n\nmapviewOptions(fgb = FALSE)\n\nmy_map <- mapView(x = locations_sf,\n                  map.types = c(\"OpenStreetMap\"))+\n          mapView(x = soil_sf, \n                  zcol = \"VEREENV\",\n                  col.regions = c(\"brown\", \n                                  \"transparent\", \n                                  \"black\", \n                                  \"yellow\"), \n                  alpha.regions = 0.4,\n                  stroke = FALSE, \n                  map.types = c(\"OpenStreetMap\"))\n\nmy_map\n```\n\nYou can then use `mapshot()` to export your map as an image file.\n\n```{r}\n#| eval: false\n#| echo: true\n#| warning: false\n#| message: false\n#| code-fold: false\n\nmapshot(my_map,\n        file = \"my_map.png\", \n        scalebar = TRUE)\n```\n\n## Take-home message\n\nGood data visualisation is essential for data exploration and analysis, as well as for presenting and publishing the results of your research. The aim of this tutorial was to give you a brief overview of the main functions available in *ggplot2* for producing high-quality, clear and informative graphs. Of course, this tutorial is far from exhaustive and many other tools are available. We encourage you to continue learning and discovering new functions available in *ggplot2* by using the popular books [R for Data Science](https://r4ds.hadley.nz/) and [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/).\n","srcMarkdownNoYaml":"\n\n## About this tutorial\n\nWelcome to this tutorial on data visualisation in R!\n\nThroughout this tutorial, **our aim is to provide you with the basic tools for visualising your data in R**. After organizing some variables, computing new ones, and filtering data for statistical analyses, we are now left with plotting and visualising our data. The aim of this tutorial is to help you master this fundamental skill!\n\nWe will work with the following published dataset on plant communities across Eurasia: **Wassen MJ, Schrader J, van Dijk J, Eppinga MB**. **2021**. [Phosphorus fertilization is eradicating the niche of northern Eurasia's threatened plant species](https://www.nature.com/articles/s41559-020-01323-w). *Nature ecology & evolution* **5**: 67--73.\n\nAt the end of this tutorial, you will also learn how to map field site locations in R.\n\nLet's get started!\n\n## Introduction to *ggplot2*\n\nWhen visualising data in R, you can of course use base R functions (e.g., `plot`, `points`, `lines`, etc.), but this tutorial is only going to focus on functions of the *ggplot2* R package. This is because *ggplot2* can produce high-quality figures very quickly, even for complex ecological datasets. With *ggplot2*, you can generate a wide variety of graphs, including scatter plots, bar charts, histograms, box plots and much more, while having control over layouts, labels and aesthetics, such as colours, sizes and shapes. *ggplot2* relies on a coherent system for building graphs: the **grammar of graphics**. Using *ggplot2* requires you to learn a new grammar, which may sound overwhelming at first, but is in fact easy to learn because it relies on a simple set of core principles.\n\n::: callout-tip\n## ggplot2: Elegant Graphics for Data Analysis\n\nThis tutorial will only give you a very brief introduction to *ggplot2*. If you want to explore all the possibilities offered by *ggplot2* for data scientists, we recommend going through Hadley Wickham's reference book: **ggplot2: Elegant Graphics for Data Analysis**. To freely access the content of this book, just click on its cover.\n\n[![](Cover_ggplot2.jpg){fig-align=\"center\" width=\"200\"}](https://ggplot2-book.org/)\n:::\n\nIn this tutorial, we will use *ggplot2* to create the following graphs:\n\n-   A box plot to explore the relationship between a continuous response variable and a categorical predictor\n-   A scatter plot to explore the relationship between two continuous variables\n-   A map to visualise field site locations\n\n::: callout-tip\n## Posit Cheat Sheets\n\nPosit, the open source data science company behind RStudio, developed some very useful cheat sheets to help you remember how to use some of the core *tidyverse* packages, including *ggplot2*. You can download the ggplot2 cheat sheet using this [link](https://rstudio.github.io/cheatsheets/html/data-visualization.html?_gl=1*19kcxbo*_ga*NzQwNjg4NjIuMTcxMjA0NzkyNA..*_ga_2C0WZ1JHG0*MTcxMjMwNDYwNS4zLjEuMTcxMjMwNDcyMS4wLjAuMA..).\n:::\n\n## Load R packages\n\nThe first step is to load all the R packages needed for this tutorial. Since *ggplot2* is included in *tidyverse*, we just need to load the *tidyverse* library. We will also need a couple of other packages, including *knitr*, *viridis, Hmisc,* and *ggpubr*. Do not forget to install them if you do not have them in your library.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\nlibrary(tidyverse)\nlibrary(knitr)\nlibrary(viridis)\nlibrary(Hmisc)\nlibrary(ggpubr)\n```\n\n## Exercise 1: Creating a box plot\n\n### Import data into R\n\n[Wassen et al (2021)](https://www.nature.com/articles/s41559-020-01323-w) showed that threatened species are most commonly found in soils with relatively low phosphorus (P) and low P to Nitrogen (N) ratio. They determined a N:P median niche value and compared species that were threatened to those that were not using a box plot (see Figure 2 in the original paper). In this first exercise, we are going to recreate and improve this visualisation.\n\nAs the data is stored in a csv file (NPsp_Wassen.csv), we will use `read_csv()` to import the data into R. This csv file is stored in our working directory, in a folder called Data_ggplot2. Store data into an R object named `data_wassen`.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\n#Import data file (csv file)\ndata_wassen <- read.csv(\"Data_ggplot2/NPsp_Wassen.csv\")\n```\n\nHave a look at how the data frame looks like using `View()` or `head()`.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\nkable(head(data_wassen, n=10))\n```\n\nHaving examined the figure in the original article (Figure 2), what variables do you think are needed to recreate this figure?\n\n### Create a ggplot\n\nYou can start creating a plot using the function `ggplot()`. Later on, we will add new layers to this ggplot object. `ggplot()` has two main arguments: `data` and `mapping`. The `data` argument is used to specify the name of the dataset that should be used to create the graph. The `mapping` argument is used to specify how variables in your dataset are linked to visual properties (referred to **aesthetics**) of your plot. You should always use the `aes()` function for the `mapping` argument. The `x` and `y` arguments of `aes()` are used to choose the x (horizontal) and y (vertical) variables of your plot, respectively. The general syntax to create a ggplot object looks like this:\n\n`ggplot(data = your_data, mapping = aes(x, y, other aesthetics))`\n\nLet's create our first ggplot using **threatened** (i.e., whether a species is threatened or not) and **NP_median** (i.e., the N:P median niche value of each species in the dataset) as the x and y variables, respectively.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median))\n```\n\nAs you can see, the structure of the plot is there, but it does not display any data yet. This is because we have not specified in our code how our observations should be represented in our plot. You can do this by defining a **geom**. In *ggplot2*, there are a number of geom to choose from. Here are a few examples (but see [ggplot2 cheat sheet](https://rstudio.github.io/cheatsheets/data-visualization.pdf) for more examples):\n\n-   `geom_point()`: This geom is used to display individual data points and create a scatter plot.\n\n-   `geom_jitter()`: This geom is similar to `geom_point()` but jitters the data to improve readability.\n\n-   `geom_line()` and `geom_path()`: These geom are used to add lines connecting observations in your graph. While `geom_path()` connects observations in the order in which they appear in the data, `geom_line()` connects observations in the order of the variable plotted on the x axis of your graph.\n\n-   `geom_boxplot()`: This geom is used to create a box plot, which is particularly useful to display and compare the distribution of a response variable for different groups.\n\n-   `geom_bar()`: This geom is used to create bar charts.\n\n-   `geom_abline()`: This geom is used to add horizontal, vertical, and diagonal lines to your graph.\n\nAs we want to create a box plot, let's use `geom_boxplot()`. In `geom_boxplot()`, use the `width` argument to make boxes more narrow (by default, `width=1`).\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median))+\n  geom_boxplot(width=0.5)\n```\n\nIt's starting to look like a graph! We can improve it even further by plotting the raw data on top of the box plot. You can do this using `geom_jitter()`. In `geom_jitter()`, use the `width` argument to adjust the horizontal spread of the data points. Set also `height=0` to make sure that data points are only jittered horizontally. We will also use the `shape` argument to choose the symbol we want to use to represent each data point. There a number of options to choose from:\n\n```{r}\n#| eval: true\n#| echo: false\n#| warning: false\n#| message: false\n#| fig-width: 3\n#| fig-height: 3\n#| fig-align: center\n\ngenerateRPointShapes<-function(){\n  oldPar<-par()\n  par(font=2, mar=c(0.5,0,0,0))\n  y=rev(c(rep(1,6),rep(2,5), rep(3,5), rep(4,5), rep(5,5)))\n  x=c(rep(1:5,5),6)\n  plot(x, y, pch = 0:25, cex=1.5, ylim=c(1,5.5), xlim=c(1,6.5), \n       axes=FALSE, xlab=\"\", ylab=\"\", bg=\"#FFCD00\")\n  text(x, y, labels=0:25, pos=3)\n  par(mar=oldPar$mar,font=oldPar$font )\n}\ngenerateRPointShapes()\n```\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median))+\n  geom_boxplot(width=0.5)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1)\n```\n\nNote that the order in which you specify the different geom matters! If `geom_jitter()` is used before `geom_boxplot()`, most of the individual data points will be hidden behind the box plots.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median))+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1)+\n  geom_boxplot(width=0.5)\n```\n\n### Personalise your ggplot\n\nIn this section, we are going to personalise our plot by adding new layers and aesthetics.\n\nThe first thing we would like to do is to fill boxes with a specific colour for each group of species (threatened versus not threatened). To achieve this, we will have to provide additional information in `aes()`. We need to introduce two new arguments: `colour` (or `color`) and `fill`. As we want the two species categories to be displayed with a different color, we can use `fill=threatened` inside `aes()`.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median,\n                     fill = threatened))+\n  geom_boxplot(width=0.5)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1)\n```\n\nWhat would happen if you use `color=threatened` instead of `fill=threatened`? What do you notice? Change the code and give it a try!\n\nBy default, when assigning a specific color to each species group, *ggplot2* uses colors that are evenly spaced around a HCL (Hue Chroma Luminance) colour circle. However, this is not necessarily the best choice, especially for colour-blind people. The colour palettes provided by `viridis()` in the *viridis* R package have been specially designed to produce graphics that are pleasing to the eye, easier to read for colour-blind people and print well in greyscale. As shown in the figure below, eight colour palettes are available in *viridis*: **magma** (option A), **inferno** (option B), **plasma** (option C), **viridis** (option D, this is the default), **cividis** (option E), **rocket** (option F), **mako** (option G), and **turbo** (option H).\n\n[![Colour palettes available in the viridis R package](viridis.png){fig-align=\"center\" width=\"600\"}](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)\n\nLet's keep on personalising our plot by specifying that we want to use the viridis (option D) color palette to create the figure. This can be done with `scale_colour_viridis()` (`scale_color_viridis()` would work too) or `scale_fill_viridis()`. These functions have a couple of arguments to play with, including `alpha` (used to make colours more or less transparent), `direction` (to change the order of the colors in the scale), `discrete` (set to TRUE if you want to assign colours to a discrete scale such as groups), and `option` (to choose the colour palette you want to use). A list of colours available in R can also be found [here](https://www.uvm.edu/~ngotelli/Rscripts/ColorChart.pdf).\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median,\n                     fill = threatened))+\n  geom_boxplot(width=0.5)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1)+\n  scale_fill_viridis(discrete = TRUE,\n                     option = \"D\",\n                     alpha = 0.5)\n```\n\nNow that we are happy with the colors used in our plot, we can keep on personalising the layout by adding new layers to our ggplot. Let's do the following:\n\n-   Rename the axis titles so that it is clear to the reader which variables are represented. If your variables have units, do not forget to indicate them in the axis titles. We can personalise axis titles using `xlab()` and `ylab()`.\n-   ggplot2 comes with a number of built-in themes that can be used to personalise how your plot should look like. By default, `theme_grey()` is used (this is the reason why our plot has a grey background). Other popular themes are `theme_bw()` (black and white theme), `theme_minimal()` (minimalistic theme), and `theme_classic()` (a classic theme with axis lines but no gridlines). Many more themes are available in *ggplot2*. We will use `theme_bw()` to personalise our plot.\n-   Make the individual points a bit more transparent using the `alpha` argument in `geom_jitter()`.\n-   Remove the points labelled as outliers by `geom_boxplot()`. As individual data points are also displayed, this information is redundant. We can get rid of these points using `outliers = FALSE` in `geom_boxplot()`.\n-   Remove the legend on the right side of the plot because this information is already provided by the x axis. This can be done using `theme()` and setting `legend.position=\"none\"`. `theme()` is a particularly important function as it allows you to personalise many aspects of your plot, such as the color, size and orientation of the text along plot axes.\n-   Along the vertical axis, we would like to have breaks at the following N:P values: 5, 10, 15, 20, 25, 30. You can do this using `scale_y_continuous()`.\n-   Change the colour of the text along the horizontal and vertical axes to black. You can do this using `theme()` and `element_text()`.\n-   Add more space between axis titles and axis labels. You can do this in `theme()`, using the `margin` argument in `element_text()`.\n-   Remove the grey grid lines in the background of the plot. This can be done in `theme()`, using `panel.grid = element_blank()`.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median,\n                     fill = threatened))+\n  geom_boxplot(width=0.5,\n               outliers=FALSE)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1,\n              alpha=0.6)+\n  scale_fill_viridis(discrete = TRUE,\n                     option = \"D\",\n                     alpha = 0.5)+\n  theme_bw()+\n  xlab(\"Are species threatened?\")+\n  ylab(\"Median N:P ratio\")+\n  scale_y_continuous(breaks=seq(from = 5,\n                                to = 30,\n                                by = 5))+\n  theme(legend.position = \"none\",\n        axis.text = element_text(colour=\"black\"),\n        axis.title.x = element_text(margin = margin(t = 10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)),\n        panel.grid = element_blank()) #r means right\n```\n\n### Compute and display summary statistics\n\nWhen comparing groups to each other, we are often interested in comparing group means and their confidence limits (often represented as 95% confidence intervals). The function `stat_summary()` allows you to add this information to your ggplot. In `stat_summary()`, `fun.data = \"mean_cl_boot\"` can be used to calculate and display the average value and 95% confidence interval estimated by bootstrapping (which is a convenient way to estimate confidence intervals without assuming that the underlying data are normally distributed).\n\nTo improve readability, we want to plot these summary statistics on the right side of each box plot, using the same colour palette (tip: add `aes()` in `stat_summary()`). In `stat_summary()`, the `position` argument allows you to fine tune the position of plotted elements. The function `position_nudge()` allows you to shift the position of items along the vertical and horizontal axes by a small amount. In our case, shifting the position of summary statistics by 0.35 units to the right seems like a good idea.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\nggplot(data = data_wassen, \n       mapping = aes(x = threatened, \n                     y = NP_median,\n                     fill = threatened))+\n  geom_boxplot(width=0.5,\n               outliers=FALSE)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1,\n              alpha=0.6)+\n  stat_summary(fun.data=\"mean_cl_boot\",\n               aes(colour = threatened),\n               position = position_nudge(x=0.35))+\n  scale_fill_viridis(discrete = TRUE,\n                     option = \"D\",\n                     alpha = 0.5)+\n  scale_colour_viridis(discrete = TRUE,\n                       option = \"D\")+\n  theme_bw()+\n  xlab(\"Are species threatened?\")+\n  ylab(\"Median N:P ratio\")+\n  scale_y_continuous(breaks=seq(from = 5,\n                                to = 30,\n                                by = 5))+\n  theme(legend.position = \"none\",\n        axis.text = element_text(colour=\"black\"),\n        axis.title.x = element_text(margin = margin(t = 10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)),\n        panel.grid = element_blank()) #r means right\n```\n\n### Integrating the pipe\n\nRemember the pipe? We introduced it in the data wrangling tutorial. How can we rewrite the code used to produce our figure using the pipe? Give it a try!\n\n```{r}\n#| eval: false\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\ndata_wassen |> \n  ggplot(mapping = aes(x = threatened, \n                       y = NP_median,\n                       fill = threatened))+\n  geom_boxplot(width=0.5,\n               outliers=FALSE)+\n  geom_jitter(width=0.1, \n              height=0, \n              shape=1,\n              alpha=0.6)+\n  stat_summary(fun.data=\"mean_cl_boot\",\n               aes(colour = threatened),\n               position = position_nudge(x=0.35))+\n  scale_fill_viridis(discrete = TRUE,\n                     option = \"D\",\n                     alpha = 0.5)+\n  scale_colour_viridis(discrete = TRUE,\n                       option = \"D\")+\n  theme_bw()+\n  xlab(\"Are species threatened?\")+\n  ylab(\"Median N:P ratio\")+\n  scale_y_continuous(breaks=seq(from = 5,\n                                to = 30,\n                                by = 5))+\n  theme(legend.position = \"none\",\n        axis.text = element_text(colour=\"black\"),\n        axis.title.x = element_text(margin = margin(t = 10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)),\n        panel.grid = element_blank()) #r means right\n```\n\n### Arrange multiple ggplots\n\nOften, we produce multiple plots that we want to put together into one figure as separate panels. But how can we easily do this? The answer is: by using `ggarrange()` in the *ggpubr* R package. It is easier to use `ggarrange()` if each individual plot is stored in a different object. Let's do this and also create a second figure (very similar to the first) displaying median P values (in mg/g) instead of median N:P values. This time, use the `size` argument in `geom_jitter()` and `stat_summary()` to reduce the size of individual data points.\n\nOnce your two plots are created and stored in separate R objects, use `ggarrange()` to create one figure with two panels (1 row, 2 columns).\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 5.9\n#| fig-height: 3.94\n#| fig-align: center\n\n#Create individual plots\n\nplot_NP <- data_wassen |> \n              ggplot(mapping = aes(x = threatened, \n                                   y = NP_median,\n                                   fill = threatened))+\n              geom_boxplot(width=0.5,\n                           outliers=FALSE)+\n              geom_jitter(width=0.1, \n                          height=0, \n                          shape=1,\n                          alpha=0.6,\n                          size=1)+\n              stat_summary(fun.data=\"mean_cl_boot\", \n                           aes(colour = threatened),\n                           position = position_nudge(x=0.35),\n                           size=0.4)+\n              scale_fill_viridis(discrete = TRUE,\n                                 option = \"D\",\n                                 alpha = 0.5)+\n              scale_colour_viridis(discrete = TRUE,\n                                   option = \"D\")+\n              theme_bw()+\n              xlab(\"Are species threatened?\")+\n              ylab(\"Median N:P ratio\")+\n              scale_y_continuous(breaks=seq(from = 5,\n                                            to = 30,\n                                            by = 5))+\n              theme(legend.position = \"none\",\n                    axis.text = element_text(colour=\"black\"),\n                    axis.title.x = element_text(margin = margin(t = 10)), #t means top\n                    axis.title.y = element_text(margin = margin(r=10)),\n                    panel.grid = element_blank()) #r means right\n\nplot_P <- data_wassen |> \n            ggplot(mapping = aes(x = threatened, \n                                 y = P_median,\n                                 fill = threatened))+\n            geom_boxplot(width=0.5,\n                         outliers=FALSE)+\n            geom_jitter(width=0.1, \n                        height=0, \n                        shape=1,\n                        alpha=0.6,\n                        size=1)+\n            stat_summary(fun.data=\"mean_cl_boot\",\n                         aes(colour = threatened),\n                         position = position_nudge(x=0.35),\n                         size=0.4)+\n            scale_fill_viridis(discrete = TRUE,\n                               option = \"D\",\n                               alpha = 0.5)+\n            scale_colour_viridis(discrete = TRUE,\n                                 option = \"D\")+\n            theme_bw()+\n            xlab(\"Are species threatened?\")+\n            ylab(\"Median P concentration (mg/g)\")+\n            scale_y_continuous(breaks=seq(from = 0,\n                                          to = 4,\n                                          by = 0.5))+\n            theme(legend.position = \"none\",\n                  axis.text = element_text(colour=\"black\"),\n                  axis.title.x = element_text(margin = margin(t = 10)), #t means top\n                  axis.title.y = element_text(margin = margin(r=10)),\n                  panel.grid = element_blank()) #r means right\n\n#Combine plots with ggarrange()\n\n(plot_final <- ggarrange(plot_NP, #This is the first panel\n                         plot_P, #This is the second panel\n                         nrow = 1,\n                         ncol = 2,\n                         align = \"hv\", #Panels need to be horizontally and vertically aligned\n                         labels = \"auto\")) #Auto-generate lower-case labels for each subplot\n```\n\n### Export high-resolution figure\n\nOnce you are happy with your figure, you can export it as a high-resolution image file (png, tiff, jpg, etc.) for your paper or presentation using `ggsave()`. In `ggsave()`, important arguments are `filename` (the name of the image file, with file extension), `plot` (the name of your ggplot object), `dpi` (desired image resolution in dots per inch), `width` (image width), `height` (image height), and `units` (the units used for width and height). By default, the figure will be saved in your working directory (see `getwd()`).\n\n```{r}\n#| eval: false\n#| echo: true\n#| warning: false\n#| message: false\n\nggsave(filename = \"Boxplot_Wassen.png\",\n       plot = plot_final,\n       dpi = 1000,\n       width = 15,\n       height=10,\n       units=\"cm\")\n```\n\n## Exercise 2: Creating a scatter plot\n\nThe second exercise of this tutorial is to use the [Wassen et al (2021)](https://www.nature.com/articles/s41559-020-01323-w) data to create a scatter plot displaying the relationship between median phosphorus (P) and potassium (K) concentrations. We also want our figure to show how this relationship differs between species groups (i.e., threatened or not threatened). Let's have a look at how to do this with *ggplot2*.\n\n### Create a ggplot\n\nFirst, create a ggplot object displaying individual data points and clear axis titles (keep on using the pipe). Let's not worry about the threat status of the species just yet.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 4\n#| fig-height: 4\n#| fig-align: center\n\ndata_wassen |> \n  ggplot(aes(x = K_median,\n             y = P_median))+\n  geom_point(shape = 1)+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10))) #r means right\n```\n\n### Personalise your ggplot\n\nIt is already a nice graph, but now we want to make it more informative by displaying the results separately for each group of species (threatened and non-threatened species). There are several ways of doing this. The first is to display the data points with a different shape (use `shape` in `aes()`) or a different colour (use `colour` or `color` in `aes()`). Let's do both! Feel free to play around with different shapes (`scale_shape_manual()`) and colour palettes. In the previous example, we used `scale_colour_viridis()` to choose our viridis colour palette. This time, we are going to define the colour options by combining `scale_color_manual()` and `viridis()`. Give it a try!\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 5\n#| fig-height: 4\n#| fig-align: center\n\ndata_wassen |> \n  ggplot(aes(x = K_median,\n             y = P_median,\n             colour = threatened,\n             shape = threatened))+\n  geom_point()+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)))+ #r means right\n  scale_shape_manual(values = c(16, 17))+\n  scale_colour_manual(values = viridis(n = 2, #Set number of colours\n                                       alpha = 0.5,\n                                       option = \"D\"))\n```\n\n### Faceting\n\nWe now have a graph showing the results separately for each group of species. However, it looks a little cluttered, with individual points overlapping each other. To improve readability, it would be preferable to present the data for threatened and non-threatened species in separate panels. This can be done with `facet_wrap()`. This function will divide our existing graph into subplots, each of which will display a subset of the data based on a categorical variable (threat status). Note that if you want to create subplots based on two variables in your dataset (a 'row' variable and a 'column' variable), using `facet_grid()` is more appropriate.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 5.9\n#| fig-height: 3.94\n#| fig-align: center\n\ndata_wassen |> \n  ggplot(aes(x = K_median,\n             y = P_median,\n             colour = threatened,\n             shape = threatened))+\n  geom_point()+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)))+ #r means right\n  scale_shape_manual(values = c(16, 17))+\n  scale_colour_manual(values = viridis(n = 2, #Set number of colours\n                                       alpha = 0.5,\n                                       option = \"D\"))+\n  facet_wrap(~threatened,\n             nrow=1,\n             ncol=2)\n```\n\n### Simplify your plot\n\nWe are getting closer to the final version of our graph, but there are still a few points to be ironed out:\n\n-   There is some redundancy in this figure because the threat status of plant species is represented by different colours, different dot shapes and in different panels. We should simplify things a little and avoid redundancy. Now that we have a specific panel for each category of species, it is no longer necessary to use a specific colour and shape for each category. This will also make it possible to do away with the legend on the right-hand side of the graph.\n-   In each panel, we would like to add a trend line ('smoother') to better visualise the shape of the relationship between our two continuous variables. This can be done using a new geom: `geom_smooth()`. In `geom_smooth()`, the `span` argument allows you to control the amount of smoothing (a large number will produce a smoother line).\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 5.9\n#| fig-height: 3.94\n#| fig-align: center\n\ndata_wassen |> \n  ggplot(aes(x = K_median,\n             y = P_median))+\n  geom_point(shape=1)+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)))+ #r means right\n  facet_wrap(~threatened,\n             nrow=1,\n             ncol=2)+\n  geom_smooth(span=1.5)\n```\n\n### Finalise your plot\n\nBefore exporting our graph as a high-resolution image file, we would like to do two things:\n\n-   Colour the trend lines using the same colours as those used for our box plot (just to make it prettier and more consistent). Make sure to remove the legend using `legend.position=\"none\"`.\n-   Rename the title of each subplot to make it more informative. Instead of \"No\" and \"Yes\", \"Not threatened\" and \"Threatened\" would be more informative. You can do this using `replace()` in `mutate()` (see tutorial on data wrangling).\n\nThat's what we need to do!\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-width: 5.9\n#| fig-height: 3.94\n#| fig-align: center\n\ndata_wassen |> \n  mutate(threatened = replace(threatened, threatened == \"No\", \"Non-threatened\")) |>\n  mutate(threatened = replace(threatened, threatened == \"Yes\", \"Threatened\")) |>\n  ggplot(aes(x = K_median,\n             y = P_median))+\n  geom_point(shape=1)+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)),\n        legend.position=\"none\",\n        axis.text = element_text(colour = \"black\"))+ #r means right\n  facet_wrap(~threatened,\n             nrow=1,\n             ncol=2)+\n  geom_smooth(span=1.5,\n              aes(colour = threatened))+\n  scale_colour_viridis(option=\"D\",\n                       discrete = TRUE)\n```\n\n### Export high-resolution figure\n\nUse `ggsave()` to export your plot as a high-resolution image.\n\n```{r}\n#| eval: false\n#| echo: true\n#| warning: false\n#| message: false\n\nplot_final <- data_wassen |> \n  mutate(threatened = replace(threatened, threatened == \"No\", \"Non-threatened\")) |>\n  mutate(threatened = replace(threatened, threatened == \"Yes\", \"Threatened\")) |>\n  ggplot(aes(x = K_median,\n             y = P_median))+\n  geom_point(shape=1)+\n  theme_bw()+\n  xlab(\"Median K concentration (mg/g)\")+\n  ylab(\"Median P concentration (mg/g)\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)), #t means top\n        axis.title.y = element_text(margin = margin(r=10)),\n        legend.position=\"none\",\n        axis.text = element_text(colour = \"black\"))+ #r means right\n  facet_wrap(~threatened,\n             nrow=1,\n             ncol=2)+\n  geom_smooth(span=1.5,\n              aes(colour = threatened))+\n  scale_colour_viridis(option=\"D\",\n                       discrete = TRUE)\n\nggsave(filename = \"Scatterplot_Wassen.png\",\n       plot = plot_final,\n       dpi = 1000,\n       width = 15,\n       height=10,\n       units=\"cm\")\n```\n\n## Exercise 3: Mapping spatial data\n\nCreating and extracting data from maps is very useful for ecological field research. This exercise will give you a brief introduction to mapping spatial data in R.\n\nFor this exercise, we will use the following files:\n\n-   A geopackage database file (GPKG) containing the spatial coordinates of field sites around Utrecht University (Locations_EFR.gpkg)\n\n-   A map of the highest ground water table (GWT_high.tif). This map is stored as a TIFF file (Tag Image File Format), which is a widely used file format for storing raster graphics images.\n\n-   A geopackage database file containing soil type information (Basisregistratie Ondergrond)\n\n### Load R packages to handle spatial data\n\nBefore starting this exercise, make sure that the *sf*, *raster*, and *mapview* packages are installed in your library.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\nlibrary(sf)\nlibrary(raster)\nlibrary(mapview)\n```\n\n### Import geospatial data\n\nGPKG files can be read using `st_read()` in th *sf* R package. Use this function to load the locations of our field sites into R. We can then plot these locations using `geom_sf()` in *ggplot2*.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-align: center\n\n#Read field site locations\nlocations_sf <- st_read(dsn = \"Data_ggplot2/Locations_EFR.gpkg\",\n                        quiet = TRUE)\n\n#Create a ggplot\nggplot(data = locations_sf)+\n  geom_sf()+\n  theme_minimal()\n```\n\nQuestion: Why do we not see a map in the background?\n\n### Add raster data (ground water)\n\nTo add information about the highest ground water table in the background of our map, we first need to read our raster data (GWT_high.tif) using `raster()`. This will create a RasterLayer object which will need to be converted into a data frame using `as.data.frame()` so that the data can be used in *ggplot2*. In our ggplot, use `geom_raster()` to add a raster layer to your graph.\n\nIn maps, the colour code used to display information is something to be considered carefully, so that your map is as informative and easy to understand as possible. In this ground water example, we would like areas with a high water table (i.e. low GWT_high values in our dataset) to appear in blue, while areas with a low water table (i.e. high GWT_high values in our dataset) would appear in red. Such a divergent colour gradient (low-medium-high) can be created using `scale_colour_gradient2()`. We will set the midpoint value to 2 (which means that values below 2 will appear blue, while values above 2 will appear red). We will also apply a pseudo-log transformation to improve the readability of our map. You can do this using the `transform` argument in `scale_fill_gradient2()`. As our raster data also contains missing values, we will use the `na.value` argument in `scale_fill_gradient2()` to make them transparent.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-align: center\n\n#Create RasterLayer object\nGWT<-raster(\"Data_ggplot2/GWT_high.tif\")\n\n#Convert to data frame\nGWT_df <- as.data.frame(GWT, \n                        xy = TRUE)\n\n#Plot raster and location data\nggplot()+\n  geom_raster(data = GWT_df, \n              aes(x = x, \n                  y = y, \n                  fill = GWT_high))+\n  geom_sf(data = locations_sf)+\n  theme_minimal()+\n  scale_fill_gradient2(name = \"Ground\\nwater\\ntable\",\n                       low = \"blue\", \n                       mid = \"white\", \n                       high = \"red\",\n                       midpoint = 2,\n                       transform = \"pseudo_log\",\n                       na.value = \"transparent\")\n```\n\nLet's now look at how we can customise the legend for this ggplot. It would be interesting to edit the break values along the colour bar and provide an informative title for each axis. Give it a try!\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-align: center\n\n#Plot raster and location data\nggplot()+\n  geom_raster(data = GWT_df, \n              aes(x = x, \n                  y = y, \n                  fill = GWT_high))+\n  geom_sf(data = locations_sf)+\n  theme_minimal()+\n  scale_fill_gradient2(\"Ground\\nwater\\ntable\",\n                       low = \"blue\", \n                       mid = \"white\", \n                       high = \"red\",\n                       midpoint = 2,\n                       transform = \"pseudo_log\",\n                       na.value = \"transparent\",\n                       breaks = c(0, 2, 10, 40))+\n  ylab(\"Latitude\")+\n  xlab(\"Longitude\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)),\n        axis.title.y = element_text(margin = margin(r=10)))\n```\n\n### Add more geospatial information (soil type)\n\nLet's create a new map with soil type information! Soil type data is stored as a geopackage (Soil_BRO.gpkg). You can read it using `st_read()`.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\nsoil_sf <- st_read(dsn = \"Data_ggplot2/Soil_BRO.gpkg\",\n                   quiet = TRUE)\n```\n\nIn `soil_sf`, the column 'VEREENV' contains soil type information. There are four soil type options in this column: DV (Peat), V (Peat), M (Clay), Z (Sand). Combine `mutate()` and `replace()` to rename elements in this column.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n\nsoil_sf <- soil_sf |> \n  mutate(VEREENV = replace(VEREENV, VEREENV %in% c(\"DV\", \"V\"), \"Peat\")) |> \n  mutate(VEREENV = replace(VEREENV, VEREENV == \"M\", \"Clay\")) |> \n  mutate(VEREENV = replace(VEREENV, VEREENV == \"Z\", \"Sand\"))\n```\n\nNow let's create our map of soil types and plot our site locations on top of it (use `geom_sf()` in both cases). Use `scale_fill_manual()` to assign colours to each soil type.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| fig-align: center\n\nggplot() +\n  geom_sf(data = soil_sf, \n          aes(fill = VEREENV),\n          alpha = 0.5) +\n  geom_sf(data = locations_sf) +\n  scale_fill_manual(name = \"Soil Type\",\n                    values = c(\"Peat\" = \"black\", \n                               \"Sand\" = \"yellow\", \n                               \"Clay\" = \"brown\"),\n                    na.value = \"transparent\") +\n  theme_minimal()+\n  ylab(\"Latitude\")+\n  xlab(\"Longitude\")+\n  theme(axis.title.x = element_text(margin = margin(t=10)),\n        axis.title.y = element_text(margin = margin(r=10)))\n```\n\n### Adding a base map\n\nYour maps look great, but they are all missing a base map. This can be done using `mapView()` in *mapview*. Have a look at the code below to see how to add a base map to our soil type map.\n\n```{r}\n#| eval: true\n#| echo: true\n#| warning: false\n#| message: false\n#| code-fold: false\n#| fig-align: center\n\nmapviewOptions(fgb = FALSE)\n\nmy_map <- mapView(x = locations_sf,\n                  map.types = c(\"OpenStreetMap\"))+\n          mapView(x = soil_sf, \n                  zcol = \"VEREENV\",\n                  col.regions = c(\"brown\", \n                                  \"transparent\", \n                                  \"black\", \n                                  \"yellow\"), \n                  alpha.regions = 0.4,\n                  stroke = FALSE, \n                  map.types = c(\"OpenStreetMap\"))\n\nmy_map\n```\n\nYou can then use `mapshot()` to export your map as an image file.\n\n```{r}\n#| eval: false\n#| echo: true\n#| warning: false\n#| message: false\n#| code-fold: false\n\nmapshot(my_map,\n        file = \"my_map.png\", \n        scalebar = TRUE)\n```\n\n## Take-home message\n\nGood data visualisation is essential for data exploration and analysis, as well as for presenting and publishing the results of your research. The aim of this tutorial was to give you a brief overview of the main functions available in *ggplot2* for producing high-quality, clear and informative graphs. Of course, this tutorial is far from exhaustive and many other tools are available. We encourage you to continue learning and discovering new functions available in *ggplot2* by using the popular books [R for Data Science](https://r4ds.hadley.nz/) and [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/).\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":600,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":5,"output-file":"data_visualisation.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","editor":"visual","editor_options":{"chunk_output_type":"console"},"theme":{"light":["cosmo","theme-light.scss"],"dark":["cosmo","theme-dark.scss"]},"code-copy":true,"code-summary":"Show me the R code","fig-cap-location":"bottom","title":"Tutorial 2: Data visualisation in R","author":[{"name":"Daniil Scheifes","email":"d.j.p.scheifes@uu.nl","affiliations":[{"name":"Environmental sciences group, Copernicus institute of sustainable development, Utrecht University"}]},{"name":"Benjamin Delory","orcid":"0000-0002-1190-8060","email":"b.m.m.delory@uu.nl","affiliations":[{"name":"Environmental sciences group, Copernicus institute of sustainable development, Utrecht University"}]}]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}